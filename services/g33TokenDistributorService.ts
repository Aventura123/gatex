import { ethers } from 'ethers';
import { collection, addDoc, getDocs, query, where, doc, getDoc, updateDoc } from 'firebase/firestore';
import { db } from '../lib/firebase';
import dotenv from 'dotenv';

// Carregar vari√°veis de ambiente do arquivo .env
dotenv.config();

// Verificar se a chave privada est√° dispon√≠vel
if (!process.env.DISTRIBUTOR_PRIVATE_KEY) {
  console.error("DISTRIBUTOR_PRIVATE_KEY n√£o encontrada. Verifique o arquivo .env ou as configura√ß√µes do ambiente.");
} else {
  console.log("DISTRIBUTOR_PRIVATE_KEY carregada com sucesso.");
}

// Removendo o carregamento de dotenv
// As vari√°veis de ambiente devem ser configuradas no ambiente de execu√ß√£o ou no arquivo .env.local

// Log para verificar se as vari√°veis de ambiente est√£o acess√≠veis
console.log("Vari√°veis de ambiente dispon√≠veis:", Object.keys(process.env));

// ABI simplificado do contrato G33TokenDistributor
const DISTRIBUTOR_ABI = [
  "function distributeTokens(address donor, uint256 donationAmountUsd) external",
  "function getAvailableTokens() external view returns (uint256)",
  "function tokensDistributed(address donor) external view returns (uint256)",
  "function totalDonated(address donor) external view returns (uint256)",
  "function totalDistributedTokens() external view returns (uint256)",
  "function totalDonationsUsd() external view returns (uint256)"
];

// Lista de URLs RPC confi√°veis para a rede Polygon
const POLYGON_RPC_URLS = [
  "https://polygon-rpc.com",
  "https://polygon.llamarpc.com",
  "https://rpc-mainnet.maticvigil.com",
  "https://polygon-mainnet.public.blastapi.io",
  "https://polygon-bor.publicnode.com",
  "https://polygon.meowrpc.com",
  "wss://polygon-mainnet.g.alchemy.com/v2/demo", // Alchemy WS p√∫blico
  "wss://ws-matic-mainnet.chainstacklabs.com"   // ChainStack WS
];

// Lista de proxies CORS confi√°veis que podem ajudar a contornar restri√ß√µes de rede
const CORS_PROXIES = [
  "https://corsproxy.io/?",
  "https://cors-anywhere.herokuapp.com/",
  "https://api.allorigins.win/raw?url="
];

// Endpoint RPC confi√°vel para usar com proxy
const RELIABLE_RPC_ENDPOINTS = [
  "https://polygon-rpc.com",
  "https://polygon.llamarpc.com"
];

// Endpoints locais para desenvolvimento
const LOCAL_RPC_URLS = [
  "http://127.0.0.1:8545", // Ganache / Hardhat padr√£o
  "http://localhost:8545"  // Alternativo
];

// Endere√ßo do contrato distribuidor e token definidos via vari√°vel de ambiente
const DISTRIBUTOR_ADDRESS = process.env.G33_TOKEN_DISTRIBUTOR_ADDRESS || "0x137c762cb3eea5c8e5a6ed2fdf41dd47b5e13455";
const G33_TOKEN_ADDRESS = process.env.G33_TOKEN_ADDRESS || "0xc6099a207e9d2d37d1203f060d2e77c1e05008fa";

// Interface para registro de doa√ß√µes
interface TokenDonation {
  donorAddress: string;
  donationAmount: number; // valor em cripto
  usdValue: number; // valor convertido para USD
  tokenAmount: number; // quantidade de tokens a serem distribu√≠dos
  transactionHash: string;
  network: string;
  cryptoSymbol: string;
  createdAt: Date;
  status: 'pending' | 'distributed' | 'failed';
  distributionTxHash?: string;
  error?: string; // Campo adicional para armazenar mensagens de erro
}

// Interface para RPC Endpoints
interface RpcEndpoint {
  url: string;
  network: {
    name: string;
    chainId: number;
  };
}

/**
 * Verifica se a aplica√ß√£o est√° em uma rede com acesso √† internet limitado
 * e que precisa usar fallbacks especiais
 */
async function isRestrictedNetwork(): Promise<boolean> {
  try {
    // Tenta acessar uma URL externa conhecida
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 3000);
    
    const response = await fetch('https://cloudflare.com', { 
      signal: controller.signal,
      method: 'HEAD'
    });
    clearTimeout(timeoutId);
    
    return !response.ok;
  } catch (error) {
    console.log('Detectada poss√≠vel restri√ß√£o de rede');
    return true;
  }
}

/**
 * Tenta conectar a um RPC atrav√©s de um proxy CORS
 * @param baseRpcUrl URL base do RPC
 * @returns Provider conectado ou null se falhar
 */
async function createProxiedProvider(baseRpcUrl: string): Promise<ethers.providers.Provider | null> {
  for (const proxyUrl of CORS_PROXIES) {
    try {
      const fullUrl = `${proxyUrl}${baseRpcUrl}`;
      console.log(`üîÑ Tentando conectar via proxy CORS: ${fullUrl}`);
      
      // Criar um provider com o URL do proxy
      const provider = new ethers.providers.JsonRpcProvider({
        url: fullUrl,
        headers: {
          "Origin": "https://gate33.com",
          "Referer": "https://gate33.com/"
        }
      });
      
      // Testar a conex√£o com timeout
      const testPromise = provider.getBlockNumber();
      const resultPromise = Promise.race([
        testPromise,
        new Promise<null>((_, reject) => 
          setTimeout(() => reject(new Error('Timeout')), 5000)
        )
      ]);
      
      const blockNumber = await resultPromise;
      console.log(`‚úÖ Conectado com sucesso via proxy CORS. Bloco: ${blockNumber}`);
      return provider;
    } catch (error) {
      console.warn(`‚ùå Falha ao conectar via proxy CORS: ${proxyUrl}`, 
        error instanceof Error ? error.message : String(error));
    }
  }
  
  return null;
}

/**
 * Servi√ßo para interagir com o contrato G33TokenDistributor
 * Este servi√ßo gerencia a distribui√ß√£o autom√°tica de tokens G33 para doadores
 */
class G33TokenDistributorService {
  private provider: ethers.providers.Provider | null = null;
  private wallet: ethers.Wallet | null = null;
  private contract: ethers.Contract | null = null;
  private distributorAddress: string | null = null;
  private isInitialized: boolean = false;
  private initializationError: string | null = null;
  private lastInitAttempt: number = 0;
  private privateKey: string | null = null;
  private isDevMode: boolean = process.env.NODE_ENV === 'development';

  constructor() {
    this.init().catch(console.error);
  }

  /**
   * Tenta criar um provider confi√°vel para a rede Polygon
   */
  private async createProvider(): Promise<ethers.providers.Provider | null> {
    const providerUrls = [
      { url: "https://polygon-rpc.com" },
      { url: "https://rpc.ankr.com/polygon" },
      { url: "https://1rpc.io/matic" }
    ];

    // Tentar conex√£o direta primeiro
    for (const {url} of providerUrls) {
      try {
        console.log(`üîÑ Tentando conectar ao RPC: ${url}`);
        
        // Criar provider com timeout
        const provider = new ethers.providers.JsonRpcProvider({ 
          url,
          timeout: 10000 // 10 segundos de timeout
        });
        
        // Testar a conex√£o com timeout adicional
        const blockNumber = await Promise.race([
          provider.getBlockNumber(),
          new Promise<never>((_, reject) => 
            setTimeout(() => reject(new Error('Timeout')), 5000)
          )
        ]);
        
        console.log(`‚úÖ Conectado com sucesso ao RPC ${url}. Bloco atual: ${blockNumber}`);
        return provider;
      } catch (error) {
        console.warn(`‚ùå Falha ao conectar ao RPC ${url}:`, error instanceof Error ? error.message : String(error));
      }
    }
    
    // Se todas as conex√µes diretas falharem, tentar via proxy CORS
    console.log("‚ö†Ô∏è Todas as conex√µes diretas falharam. Tentando via proxy CORS...");
    
    for (const baseRpcUrl of RELIABLE_RPC_ENDPOINTS) {
      const proxiedProvider = await createProxiedProvider(baseRpcUrl);
      if (proxiedProvider) {
        return proxiedProvider;
      }
    }
    
    // Se ainda falhar, tentar conex√£o com fallback de HTTP customizado
    try {
      console.log("‚ö†Ô∏è Tentando conex√£o com fallback HTTP customizado...");
      
      // Criar um provider customizado que usa fetch diretamente
      const url = "https://polygon-rpc.com";
      
      // Definir uma fun√ß√£o de fetch customizada
      const myCustomFetch = async (url: string, payload: string): Promise<string> => {
        try {
          const headers = {
            'Content-Type': 'application/json',
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
            'Origin': 'https://gate33.com',
            'Referer': 'https://gate33.com/'
          };
          
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 15000);
          
          const response = await fetch(url, {
            method: 'POST',
            headers,
            body: payload,
            signal: controller.signal
          });
          
          clearTimeout(timeoutId);
          
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          
          return await response.text();
        } catch (error) {
          console.error("Erro no fetch customizado:", error);
          throw error;
        }
      };
      
      // Usar o JsonRpcProvider com conex√£o b√°sica
      const customProvider = new ethers.providers.JsonRpcProvider(url);
      
      // Substituir a fun√ß√£o de envio de solicita√ß√£o do provider
      const originalSend = customProvider.send;
      customProvider.send = async (method: string, params: Array<any>): Promise<any> => {
        try {
          console.log(`Chamando m√©todo ${method} com fetch customizado`);
          
          const payload = JSON.stringify({
            method,
            params,
            id: Math.floor(Math.random() * 1000000),
            jsonrpc: "2.0"
          });
          
          const result = await myCustomFetch(url, payload);
          const json = JSON.parse(result);
          
          if (json.error) {
            console.error(`Erro RPC: ${json.error.message || JSON.stringify(json.error)}`);
            throw new Error(json.error.message || "Erro desconhecido");
          }
          
          return json.result;
        } catch (error) {
          console.error("Erro ao enviar requisi√ß√£o RPC:", error);
          // Tentar o m√©todo original em caso de falha
          return originalSend(method, params);
        }
      };
      
      // Testar a conex√£o
      const blockNumber = await customProvider.getBlockNumber();
      console.log(`‚úÖ Conectado com sucesso usando fetch customizado. Bloco: ${blockNumber}`);
      return customProvider;
    } catch (error) {
      console.error("‚ùå Falha tamb√©m na conex√£o com fetch customizado:", 
        error instanceof Error ? error.message : String(error));
    }
    
    // Se em desenvolvimento, criar um provider fake para testes
    if (this.isDevMode) {
      console.warn("üî∂ MODO DE DESENVOLVIMENTO: Criando provider simulado para testes");
      
      // Criar um provider simulado que retorna valores fixos para testes
      const fakeProvider = {
        getNetwork: async () => ({ chainId: 137, name: "polygon" }),
        getBlockNumber: async () => 42000000,
        getGasPrice: async () => ethers.utils.parseUnits("30", "gwei"),
        getBalance: async () => ethers.utils.parseEther("10"),
        getTransactionCount: async () => 0,
        call: async () => "0x",
        estimateGas: async () => ethers.BigNumber.from(200000),
        sendTransaction: async (tx: string) => ({ 
          hash: "0x" + "1".repeat(64),
          wait: async () => ({ status: 1, gasUsed: ethers.BigNumber.from(150000) })
        }),
        // Outros m√©todos necess√°rios para testes
        getFeeData: async () => ({
          maxFeePerGas: ethers.utils.parseUnits("50", "gwei"),
          maxPriorityFeePerGas: ethers.utils.parseUnits("30", "gwei"),
          gasPrice: ethers.utils.parseUnits("35", "gwei")
        }),
      } as unknown as ethers.providers.Provider;
      
      return fakeProvider;
    }

    return null;
  }

  /**
   * Testa a conectividade com um endpoint RPC
   */
  private async testRpcEndpoint(url: string): Promise<{success: boolean, latency?: number, error?: string}> {
    const start = Date.now();
    
    try {
      // Primeiro testa se consegue fazer uma requisi√ß√£o HTTP b√°sica
      console.log(`üîç Testando conectividade HTTP b√°sica para ${url}...`);
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 5000);
      
      try {
        const response = await fetch(url, {
          method: 'POST',
          body: JSON.stringify({
            jsonrpc: '2.0',
            method: 'eth_blockNumber',
            params: [],
            id: 1
          }),
          headers: {
            'Content-Type': 'application/json'
          },
          signal: controller.signal
        });
        
        clearTimeout(timeoutId);
        
        if (!response.ok) {
          return {
            success: false,
            latency: Date.now() - start,
            error: `HTTP ${response.status}: ${response.statusText}`
          };
        }
        
        const data = await response.json();
        console.log(`‚úÖ RPC ${url} respondeu em ${Date.now() - start}ms`);
        return {
          success: true,
          latency: Date.now() - start
        };
        
      } catch (fetchError) {
        if (fetchError instanceof Error) {
          if (fetchError.name === 'AbortError') {
            return {
              success: false,
              error: 'Timeout'
            };
          }
          return {
            success: false,
            error: fetchError.message
          };
        }
        return {
          success: false,
          error: 'Unknown error occurred'
        };
      }
      
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Erro desconhecido'
      };
    }
  }

  /**
   * Testa todos os RPCs dispon√≠veis e retorna um relat√≥rio
   */
  private async testAllRpcs(): Promise<RpcEndpoint[]> {
    const endpoints: RpcEndpoint[] = [
      {
        url: "https://polygon-rpc.com",
        network: { name: "polygon", chainId: 137 }
      },
      {
        url: "https://rpc.ankr.com/polygon",
        network: { name: "polygon", chainId: 137 }
      },
      {
        url: "https://polygon.llamarpc.com",
        network: { name: "polygon", chainId: 137 }
      }
    ];
    
    console.log("\nüîç Iniciando teste de conectividade RPC...");
    
    const workingEndpoints: RpcEndpoint[] = [];
    
    for (const endpoint of endpoints) {
      console.log(`\nTestando ${endpoint.url}...`);
      const result = await this.testRpcEndpoint(endpoint.url);
      
      if (result.success) {
        console.log(`‚úÖ ${endpoint.url}: OK (${result.latency}ms)`);
        workingEndpoints.push(endpoint);
      } else {
        console.log(`‚ùå ${endpoint.url}: Falha - ${result.error}`);
      }
    }
    
    console.log("\nTeste de conectividade RPC conclu√≠do.");
    return workingEndpoints;
  }

  /**
   * Obt√©m a chave privada de v√°rias fontes poss√≠veis
   * @returns A chave privada ou null se n√£o encontrada
   */
  private getPrivateKey(): string | null {
    // Log para debug
    console.log("Buscando chave privada do distribuidor...");
    
    // Verificar se a vari√°vel DISTRIBUTOR_PRIVATE_KEY est√° acess√≠vel
    if (process.env.DISTRIBUTOR_PRIVATE_KEY) {
      console.log("DISTRIBUTOR_PRIVATE_KEY encontrada no ambiente de execu√ß√£o.");
    } else {
      console.error("DISTRIBUTOR_PRIVATE_KEY n√£o encontrada no ambiente de execu√ß√£o.");
    }
    
    // Lista de poss√≠veis nomes de vari√°veis de ambiente para a chave privada
    const possibleEnvKeys = [
      "DISTRIBUTOR_PRIVATE_KEY",
      "PRIVATE_KEY_DISTRIBUTOR",
      "TOKEN_DISTRIBUTOR_KEY",
      "POLYGON_DISTRIBUTOR_KEY",
      "WALLET_PRIVATE_KEY",
      "PRIVATE_KEY",
      "OWNER_PRIVATE_KEY"
    ];
    
    // Verificar cada uma das vari√°veis de ambiente poss√≠veis
    for (const keyName of possibleEnvKeys) {
      if (process.env[keyName]) {
        let privateKey = process.env[keyName];
        console.log(`Encontrada chave privada em vari√°vel: ${keyName}`);
        
        // Adicionar prefixo 0x se necess√°rio
        if (!privateKey.startsWith('0x')) {
          privateKey = '0x' + privateKey;
          console.log("Adicionado prefixo '0x' √† chave privada");
        }
        
        return privateKey;
      }
    }
    
    // APENAS EM DESENVOLVIMENTO: Se n√£o encontrou chave e estamos em desenvolvimento, usar simulada
    if (this.isDevMode) {
      throw new Error("Chave privada n√£o encontrada. Verifique as vari√°veis de ambiente.");
    }
    
    return null;
  }

  /**
   * Inicializa o servi√ßo carregando configura√ß√µes e conectando ao contrato
   * @param forceInit Se verdadeiro, for√ßa a inicializa√ß√£o mesmo se uma tentativa recente foi feita
   */
  async init(forceInit: boolean = false): Promise<void> {
    try {
      console.log("üîÑ Iniciando G33TokenDistributorService...");
      
      // Evitar tentativas frequentes de inicializa√ß√£o apenas quando n√£o for√ßado
      const now = Date.now();
      if (!forceInit && this.lastInitAttempt > 0 && (now - this.lastInitAttempt) < 60000) {
        console.log("Tentativa de inicializa√ß√£o muito recente, aguardando antes de tentar novamente");
        return;
      }
      
      this.lastInitAttempt = now;
      this.initializationError = null;
      
      // Log detalhado do modo de execu√ß√£o
      console.log("Iniciando G33TokenDistributorService no modo:", this.isDevMode ? "desenvolvimento" : "produ√ß√£o");
      console.log("Ambiente NODE_ENV:", process.env.NODE_ENV);
      console.log("NEXT_PUBLIC_DEVELOPMENT_MODE:", process.env.NEXT_PUBLIC_DEVELOPMENT_MODE);
      
      // Debug para verificar vari√°veis de ambiente
      console.log("Vari√°veis de ambiente relacionadas:", Object.keys(process.env).filter(key => 
        key.includes('DISTRIBUTOR') || 
        key.includes('TOKEN') || 
        key.includes('PROVIDER') ||
        key.includes('RPC') ||
        key.includes('PRIVATE')
      ));
      
      // Log para listar todas as vari√°veis de ambiente dispon√≠veis
      console.log("Vari√°veis de ambiente dispon√≠veis:", Object.keys(process.env));
      
      // Obter a chave privada
      this.privateKey = this.getPrivateKey();
      
      // Verificar se a chave privada foi encontrada
      if (!this.privateKey) {
        throw new Error("Chave privada do distribuidor n√£o encontrada. Verifique as vari√°veis de ambiente.");
      }
      
      // Verificar o formato da chave privada
      if (!/^0x[a-fA-F0-9]{64}$/.test(this.privateKey)) {
        console.warn(`‚ö†Ô∏è Aviso: Chave privada parece estar no formato incorreto. Comprimento: ${this.privateKey.length}, esperado: 66 caracteres.`);
        
        // Se estiver em desenvolvimento, corrigir a chave
        if (this.isDevMode) {
          this.privateKey = "0x1234567890123456789012345678901234567890123456789012345678901234";
          console.log("‚ö†Ô∏è [DESENVOLVIMENTO] Substituindo com chave simulada devido a formato incorreto.");
        } else {
          throw new Error("Formato inv√°lido da chave privada do distribuidor. Verifique as vari√°veis de ambiente.");
        }
      }
      
      // Retry logic for Firestore operations
      const maxRetries = 3;
      let retryCount = 0;
      let configDoc = null;

      while (retryCount < maxRetries) {
        try {
          configDoc = await getDoc(doc(db, "settings", "contractConfig"));
          if (configDoc.exists()) break;
          throw new Error("Documento de configura√ß√£o do contrato n√£o encontrado no Firebase");
        } catch (error) {
          retryCount++;
          const errorMessage = error instanceof Error ? error.message : String(error);
          console.warn(`Tentativa ${retryCount} de obter configura√ß√£o do contrato falhou:`, errorMessage);
          if (retryCount >= maxRetries) throw new Error("Falha ao obter configura√ß√£o do contrato ap√≥s v√°rias tentativas");
          await new Promise((resolve) => setTimeout(resolve, 2000)); // Esperar 2 segundos antes de tentar novamente
        }
      }
      
      // Use environment variable or fallback for distributor address
      this.distributorAddress = DISTRIBUTOR_ADDRESS;
      console.log(`Endere√ßo do distribuidor definido: ${this.distributorAddress}`);

      if (!this.distributorAddress) {
        throw new Error("Endere√ßo do distribuidor n√£o est√° configurado.");
      }
      
      console.log("Configurando provider para a rede Polygon...");
      try {
        this.provider = await this.createProvider();
        
        if (!this.provider) {
          throw new Error("N√£o foi poss√≠vel estabelecer conex√£o com nenhum RPC. Verifique os endpoints e a conectividade de rede.");
        }
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        console.error("Erro ao configurar provider:", errorMessage);
        throw new Error("Erro cr√≠tico ao configurar provider para a rede Polygon.");
      }
      
      if (!this.provider) {
        throw new Error("N√£o foi poss√≠vel estabelecer conex√£o com nenhum RPC");
      }

      // Configurar wallet com provider j√° estabelecido
      if (this.privateKey) {
        this.wallet = new ethers.Wallet(this.privateKey, this.provider);
        console.log("‚úÖ Wallet configurada com sucesso");
      }
      
      try {
        this.provider = this.provider;
        this.wallet = new ethers.Wallet(this.privateKey, this.provider);
        console.log("Chave privada configurada com sucesso.");
        
        // Log da chave privada usada para inicializar o wallet
        console.log(`Chave privada usada: ${this.privateKey}`);
        // Log do endere√ßo gerado a partir da chave privada
        const generatedWalletAddress = await this.wallet.getAddress();
        console.log(`Endere√ßo gerado a partir da chave privada: ${generatedWalletAddress}`);

        // Removendo redefini√ß√£o da vari√°vel 'walletAddress'
        console.log(`Carteira do distribuidor configurada: ${generatedWalletAddress.substring(0, 6)}...${generatedWalletAddress.substring(generatedWalletAddress.length - 4)}`);
        
        // Conectar ao contrato
        this.contract = new ethers.Contract(this.distributorAddress, DISTRIBUTOR_ABI, this.wallet);
        
        // Verificar se o contrato est√° acess√≠vel
        try {
          const availableTokens = await this.contract.getAvailableTokens();
          console.log(`Contrato do distribuidor conectado com sucesso. Tokens dispon√≠veis: ${ethers.utils.formatEther(availableTokens)}`);
          this.isInitialized = true;
        } catch (contractError: unknown) {
          const errorMessage = contractError instanceof Error 
            ? contractError.message
            : "Erro desconhecido ao acessar fun√ß√µes do contrato";
            
          throw new Error(`Erro ao acessar fun√ß√µes do contrato: ${errorMessage}`);
        }
      } catch (walletError: unknown) {
        const errorMessage = walletError instanceof Error 
          ? walletError.message
          : "Erro desconhecido";
          
        console.error("Erro ao criar carteira com a chave privada fornecida:", errorMessage);
        throw new Error(`Erro ao criar carteira: ${errorMessage}. Verifique se a chave privada est√° no formato correto.`);
      }
      
      // Verificar o chainId da rede conectada
      const network = await this.provider!.getNetwork();
      console.log(`Conectado √† rede: ${network.name} (chainId: ${network.chainId})`);
      if (network.chainId !== 137) {
        throw new Error(`Provedor RPC conectado √† rede errada. Esperado: Polygon Mainnet (chainId 137), Atual: ${network.chainId}`);
      }

      return;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      this.initializationError = errorMessage;

      // Handle offline mode gracefully
      if (errorMessage.includes("offline")) {
        console.error("Firestore est√° offline. O servi√ßo ser√° inicializado em modo limitado.");
        this.isInitialized = false; // Marcar como n√£o inicializado, mas sem lan√ßar erro cr√≠tico
      } else {
        console.error("Erro ao inicializar G33TokenDistributorService:", errorMessage);
        this.isInitialized = false;
      }
    }
  }

  /**
   * Verifica se o servi√ßo est√° inicializado e pronto para uso
   * @returns Verdadeiro se o servi√ßo estiver inicializado
   */
  private async ensureInitialized(): Promise<boolean> {
    if (this.isInitialized) return true;
    
    // Tentar inicializar novamente
    await this.init();
    return this.isInitialized;
  }
  
  /**
   * Verifica se o servi√ßo est√° inicializado (m√©todo p√∫blico)
   * @returns Status de inicializa√ß√£o do servi√ßo
   */
  public checkIsInitialized(): boolean {
    return this.isInitialized;
  }
  
  /**
   * Obt√©m o erro de inicializa√ß√£o, se houver
   * @returns Mensagem de erro ou null
   */
  public getInitializationError(): string | null {
    return this.initializationError;
  }

  /**
   * Verifica se um endere√ßo est√° autorizado como distribuidor no contrato
   * @param address Endere√ßo a ser verificado
   * @returns true se o endere√ßo est√° autorizado, false caso contr√°rio
   */
  async isAuthorizedDistributor(address: string): Promise<boolean> {
    try {
      if (!(await this.ensureInitialized())) {
        return false;
      }
      
      // Criar um contrato com interface estendida que inclui o m√©todo distributors
      const extendedContract = new ethers.Contract(
        this.distributorAddress!,
        [
          ...DISTRIBUTOR_ABI,
          "function distributors(address) external view returns (bool)",
          "function owner() external view returns (address)"
        ],
        // Corrigindo o problema de tipo, garantindo que provider n√£o seja null
        this.provider || undefined
      );
      
      // Verificar se o endere√ßo √© um distribuidor autorizado
      const isDistributor = await extendedContract.distributors(address);
      if (isDistributor) {
        console.log(`‚úÖ O endere√ßo ${address} √© um distribuidor autorizado`);
        return true;
      }
      
      // Verificar se o endere√ßo √© o propriet√°rio do contrato
      const owner = await extendedContract.owner();
      if (owner.toLowerCase() === address.toLowerCase()) {
        console.log(`‚úÖ O endere√ßo ${address} √© o propriet√°rio do contrato`);
        return true;
      }
      
      console.warn(`‚ö†Ô∏è O endere√ßo ${address} N√ÉO √© um distribuidor autorizado nem o propriet√°rio`);
      return false;
    } catch (error) {
      console.error(`Erro ao verificar se ${address} √© um distribuidor autorizado:`, error);
      return false;
    }
  }

  /**
   * Distribui tokens G33 para um doador com base no valor da doa√ß√£o em USD
   * @param donorAddress Endere√ßo do doador
   * @param usdValue Valor da doa√ß√£o em USD (n√∫mero decimal)
   * @param waitForConfirmation Se verdadeiro, aguarda confirma√ß√£o da transa√ß√£o
   * @returns Hash da transa√ß√£o de distribui√ß√£o ou null se falhar
   */
  async distributeTokens(donorAddress: string, usdValue: number, waitForConfirmation: boolean = false): Promise<string | null> {
    try {
      if (!(await this.ensureInitialized())) {
        throw new Error(`Servi√ßo n√£o inicializado. Erro: ${this.initializationError || "Desconhecido"}`);
      }
      
      // VALIDA√á√ÉO CR√çTICA: O contrato G33TokenDistributorV2 n√£o processa valores menores que 1 USD
      // Isso ocorre porque o contrato faz: tokenAmount = donationAmountUsd / 100 (divis√£o inteira)
      // Se o valor for menor que 100 (1 USD), o resultado ser√° 0 tokens
      if (usdValue < 1) {
        throw new Error(`Valor m√≠nimo para distribui√ß√£o de tokens √© 1 USD. Valor informado: ${usdValue} USD`);
      }

      // VALIDA√á√ÉO CR√çTICA: Garantir que o valor enviado √© um inteiro
      // O contrato n√£o suporta fra√ß√µes de token
      if (usdValue % 1 !== 0) {
        console.warn(`‚ö†Ô∏è Aviso: O valor USD ${usdValue} cont√©m decimais e ser√° arredondado para ${Math.floor(usdValue)} USD`);
        usdValue = Math.floor(usdValue);
      }
      
      // Verificar se h√° tokens dispon√≠veis
      const availableTokensWei = await this.contract!.getAvailableTokens();
      const availableTokens = parseFloat(ethers.utils.formatEther(availableTokensWei));
      const tokensNeeded = usdValue; // 1 token por 1 USD
      
      console.log(`Distribui√ß√£o de tokens: ${tokensNeeded} tokens necess√°rios, ${availableTokens} tokens dispon√≠veis`);
      
      if (availableTokens < tokensNeeded) {
        throw new Error(`Tokens insuficientes no contrato distribuidor. Dispon√≠vel: ${availableTokens}, Necess√°rio: ${tokensNeeded}`);
      }
      
      // Escalar valor USD para o formato esperado pelo contrato G33TokenDistributorV2
      // O contrato espera o valor em centavos (x100) para precis√£o de 2 casas decimais
      const usdValueScaled = Math.round(usdValue * 100); // Usar Math.round para evitar problemas de arredondamento

      console.log(`Valor USD original: ${usdValue}`);
      console.log(`Valor escalado para o contrato (x100): ${usdValueScaled}`);
      console.log(`O doador receber√° ${usdValue} tokens completos G33`);
      
      // NOVO: Validar endere√ßo do doador
      if (!ethers.utils.isAddress(donorAddress)) {
        throw new Error(`Endere√ßo do doador inv√°lido: ${donorAddress}`);
      }
      
      // Verificar o endere√ßo da carteira do distribuidor para diagn√≥stico
      const walletAddress = await this.wallet!.getAddress();
      console.log(`Carteira do distribuidor que assinar√° a transa√ß√£o: ${walletAddress}`);
      
      // Verificar se o endere√ßo do contrato distribuidor est√° definido
      if (!this.distributorAddress) {
        throw new Error("Endere√ßo do contrato distribuidor n√£o est√° definido");
      }
      
      // VERIFICA√á√ÉO: Verificar se o endere√ßo do contrato e o endere√ßo do wallet s√£o iguais
      // Isso pode acontecer em configura√ß√£o incorreta e causar erros de "insufficient funds"
      if (this.distributorAddress.toLowerCase() === walletAddress.toLowerCase()) {
        console.warn("‚ö†Ô∏è ALERTA: O endere√ßo da carteira e o endere√ßo do contrato s√£o iguais!");
        console.warn("Este √© um problema de configura√ß√£o que pode causar erros de 'insufficient funds'");
        console.warn("O contrato em si n√£o deve ser usado como assinador de transa√ß√µes");
      }
      
      // NOVO: Verificar se j√° houve uma transa√ß√£o recente id√™ntica
      console.log("Verificando hist√≥rico de doa√ß√µes recentes...");
      try {
        const donationRegistry = collection(db, 'tokenDonations');
        const q = query(
          donationRegistry,
          where('donorAddress', '==', donorAddress),
          where('usdValue', '==', usdValue),
          where('status', 'in', ['distributed', 'pending']),
        );
        
        const existingDonations = await getDocs(q);
        if (!existingDonations.empty) {
          const recentDonations = existingDonations.docs.filter(doc => {
            const donation = doc.data();
            const timestamp = donation.createdAt?.toDate?.() || new Date(donation.createdAt);
            const minutesSince = (Date.now() - timestamp.getTime()) / (1000 * 60);
            return minutesSince < 5; // Doa√ß√µes nos √∫ltimos 5 minutos
          });
          
          if (recentDonations.length > 0) {
            const recentDonation = recentDonations[0].data();
            console.warn(`üö® Encontrada doa√ß√£o muito recente (√∫ltimos 5 minutos) para o mesmo endere√ßo e valor`);
            if (recentDonation.distributionTxHash) {
              console.warn(`Hash da transa√ß√£o recente: ${recentDonation.distributionTxHash}`);
              console.warn("Aguardando 10 segundos para evitar problemas de nonce...");
              await new Promise(resolve => setTimeout(resolve, 10000));
            }
          }
        }
      } catch (dbError) {
        console.warn("Erro ao verificar doa√ß√µes anteriores:", dbError);
        // N√£o interromper o fluxo por falha na verifica√ß√£o de duplicidade
      }
      
      // NOVO: Verificar permiss√µes da carteira como distribuidora
      try {
        const isAuthorized = await this.isAuthorizedDistributor(walletAddress);
        if (!isAuthorized) {
          throw new Error(`A carteira ${walletAddress} n√£o est√° autorizada como distribuidora. A transa√ß√£o seria revertida.`);
        }
        console.log(`‚úÖ Carteira autorizada como distribuidora!`);
      } catch (authError) {
        console.error("Erro ao verificar permiss√µes de distribuidor:", authError);
        throw new Error(`Falha ao verificar permiss√µes de distribuidor: ${authError instanceof Error ? authError.message : String(authError)}`);
      }
      
      // NOVO: Fazer uma simula√ß√£o pr√©via para detectar erros
      try {
        console.log(`Realizando simula√ß√£o pr√©via da transa√ß√£o...`);
        await this.contract!.callStatic.distributeTokens(donorAddress, usdValueScaled, {
          from: walletAddress
        });
        console.log("‚úÖ Simula√ß√£o pr√©via bem-sucedida! A transa√ß√£o deve funcionar.");
      } catch (simError: any) {
        // Extrair informa√ß√£o √∫til do erro de simula√ß√£o
        console.error("‚ùå A simula√ß√£o da transa√ß√£o falhou! Erro:", 
          simError instanceof Error ? simError.message : String(simError));
        
        // Analisar o erro para fornecer informa√ß√µes mais √∫teis
        let errorMessage = "Simula√ß√£o falhou";
        
        if (simError.error?.message) {
          errorMessage = simError.error.message;
        } else if (simError.message) {
          errorMessage = simError.message;
        }
        
        if (errorMessage.includes("Insufficient tokens")) {
          throw new Error(`Tokens insuficientes no contrato distribuidor.`);
        } else if (errorMessage.includes("Not authorized")) {
          throw new Error(`Conta ${walletAddress} n√£o tem permiss√£o para distribuir tokens.`);
        } else if (errorMessage.includes("execution reverted")) {
          throw new Error(`Simula√ß√£o falhou: ${errorMessage}. Verifique o saldo e permiss√µes do contrato.`);
        }
        
        throw new Error(`Simula√ß√£o pr√©via falhou: ${errorMessage}`);
      }
      
      // M√©todo padr√£o: Usar a carteira configurada no servi√ßo
      // ----------------------------------------------------- 
      console.log("Usando carteira configurada no servi√ßo para distribuir tokens...");
      
      // Verificar saldo da carteira para gas
      console.log(`Verificando saldo da carteira que assina a transa√ß√£o: ${walletAddress}`);
      const walletBalance = await this.provider!.getBalance(walletAddress);
      console.log(`Saldo da carteira (direto do provedor RPC): ${ethers.utils.formatEther(walletBalance)} MATIC`);
      
      // Log do n√≥ RPC usado
      if (this.provider instanceof ethers.providers.JsonRpcProvider) {
        console.log(`Usando n√≥ RPC: ${this.provider.connection.url}`);
      }
      
      const ignoreBalanceCheck = true;
      
      // Obter fee data atual para garantir valores apropriados de gas
      const feeData = await this.provider!.getFeeData();
      console.log("Fees atuais da rede:", {
        maxFeePerGas: feeData.maxFeePerGas ? ethers.utils.formatUnits(feeData.maxFeePerGas, "gwei") + " gwei" : "N/A",
        maxPriorityFeePerGas: feeData.maxPriorityFeePerGas ? ethers.utils.formatUnits(feeData.maxPriorityFeePerGas, "gwei") + " gwei" : "N/A",
        gasPrice: feeData.gasPrice ? ethers.utils.formatUnits(feeData.gasPrice, "gwei") + " gwei" : "N/A"
      });
      
      // IMPORTANTE: Polygon exige pelo menos 25 gwei para maxPriorityFeePerGas (gas tip cap)
      // Erro mostra: minimum needed 25000000000 (25 gwei)
      // Vamos usar valores mais altos para garantir que a transa√ß√£o seja aceita
      const MIN_GAS_PRICE = ethers.utils.parseUnits("30", "gwei"); 
      const MIN_PRIORITY_FEE = ethers.utils.parseUnits("50", "gwei"); // Aumentado de 30 para 50
      const MIN_FEE_PER_GAS = ethers.utils.parseUnits("100", "gwei"); // Aumentado de 50 para 100
      
      // Usar o maior entre o valor m√≠nimo e o sugerido pelo provider
      const gasPrice = feeData.gasPrice && feeData.gasPrice.gt(MIN_GAS_PRICE) 
        ? feeData.gasPrice 
        : MIN_GAS_PRICE;
        
      // Para transa√ß√µes EIP-1559 (tipo 2), usar maxFeePerGas e maxPriorityFeePerGas
      // Garantir que o minimo de 50 gwei para priority fee seja respeitado
      const maxPriorityFeePerGas = feeData.maxPriorityFeePerGas && feeData.maxPriorityFeePerGas.gt(MIN_PRIORITY_FEE)
        ? feeData.maxPriorityFeePerGas
        : MIN_PRIORITY_FEE;
      
      const maxFeePerGas = feeData.maxFeePerGas && feeData.maxFeePerGas.gt(MIN_FEE_PER_GAS)
        ? feeData.maxFeePerGas
        : MIN_FEE_PER_GAS;
      
      // Aumentar o gas limit para garantir que haja gas suficiente
      const gasLimit = 300000; // Aumentado de 200000 para 300000
      
      // Calcular custo estimado (usando o maior valor poss√≠vel)
      const estimatedCost = maxFeePerGas.mul(gasLimit);
      console.log(`Custo estimado: ${ethers.utils.formatEther(estimatedCost)} MATIC`);
      
      if (!ignoreBalanceCheck && walletBalance.lt(estimatedCost)) {
        throw new Error(`Saldo insuficiente para esta transa√ß√£o. Necess√°rio: ${ethers.utils.formatEther(estimatedCost)} MATIC, Dispon√≠vel: ${ethers.utils.formatEther(walletBalance)} MATIC`);
      }
      
      // Obter nonce
      const nonce = await this.provider!.getTransactionCount(walletAddress, "latest");
      
      // NOVO: usar diretamente o contrato em vez de construir a transa√ß√£o manualmente
      try {
        console.log(`Preparando chamada direta ao contrato com gasLimit ${gasLimit}...`);
        
        // Configurar gasLimit explicitamente
        const overrides = {
          maxFeePerGas,
          maxPriorityFeePerGas,
          gasLimit,
          nonce,
        };
        
        // Chamar o contrato diretamente em vez de construir a transa√ß√£o manualmente
        console.log(`Enviando transa√ß√£o via contrato.distributeTokens...`);
        const tx = await this.contract!.distributeTokens(donorAddress, usdValueScaled, overrides);
        console.log(`Transa√ß√£o enviada: ${tx.hash}`);
        
        // Aguardar confirma√ß√£o se necess√°rio
        if (waitForConfirmation) {
          console.log(`Aguardando confirma√ß√£o da transa√ß√£o ${tx.hash}...`);
          
          // Definir timeout e m√°ximo de tentativas para evitar espera infinita
          const maxAttempts = 30; // Aumentado o n√∫mero de tentativas
          const delayBetweenAttempts = 5000; // 5 segundos entre tentativas
          let attempts = 0;
          
          // Fun√ß√£o para esperar um recibo com timeout
          const waitForReceipt = async (): Promise<ethers.providers.TransactionReceipt | null> => {
            while (attempts < maxAttempts) {
              attempts++;
              try {
                const receipt = await this.provider!.getTransactionReceipt(tx.hash);
                if (receipt) {
                  return receipt;
                }
                
                console.log(`Tentativa ${attempts}/${maxAttempts}: Transa√ß√£o ainda pendente...`);
                await new Promise(resolve => setTimeout(resolve, delayBetweenAttempts));
              } catch (error) {
                console.warn(`Erro ao verificar recibo (tentativa ${attempts}):`, error);
                await new Promise(resolve => setTimeout(resolve, delayBetweenAttempts));
              }
            }
            
            // Se chegou aqui, n√£o conseguiu obter o recibo
            console.warn(`Tempo limite excedido (${maxAttempts * delayBetweenAttempts / 1000}s). A transa√ß√£o ainda pode ser confirmada posteriormente.`);
            return null;
          };
          
          const receipt = await waitForReceipt();
          if (receipt) {
            console.log(`Transa√ß√£o confirmada! Gas usado: ${receipt.gasUsed.toString()}`);
            
            // Verificar se a transa√ß√£o foi bem-sucedida
            if (receipt.status === 0) {
              console.error("‚ùå A transa√ß√£o foi confirmada, mas a execu√ß√£o do contrato falhou (execution reverted)!");
              console.log("Verifique a transa√ß√£o em: https://polygonscan.com/tx/" + tx.hash);
              
              // NOVO: Tentar novamente com outros par√¢metros
              console.log("Tentando novamente com par√¢metros diferentes...");
              
              // Esperar 10 segundos antes de tentar novamente
              await new Promise(resolve => setTimeout(resolve, 10000));
              
              // Incrementar o nonce para evitar substituir a transa√ß√£o anterior
              const newNonce = await this.provider!.getTransactionCount(walletAddress, "latest");
              
              // Aumentar o gas limit e as fees para ter certeza que vai funcionar
              const newOverrides = {
                maxFeePerGas: ethers.utils.parseUnits("150", "gwei"),
                maxPriorityFeePerGas: ethers.utils.parseUnits("100", "gwei"),
                gasLimit: 500000,
                nonce: newNonce,
              };
              
              console.log("Enviando nova tentativa com configura√ß√µes:", {
                maxFeePerGas: ethers.utils.formatUnits(newOverrides.maxFeePerGas, "gwei") + " gwei",
                maxPriorityFeePerGas: ethers.utils.formatUnits(newOverrides.maxPriorityFeePerGas, "gwei") + " gwei",
                gasLimit: newOverrides.gasLimit.toString(),
                nonce: newOverrides.nonce,
              });
              
              try {
                const retryTx = await this.contract!.distributeTokens(donorAddress, usdValueScaled, newOverrides);
                console.log(`Nova transa√ß√£o enviada: ${retryTx.hash}`);
                return retryTx.hash;
              } catch (retryError) {
                console.error("‚ùå Tamb√©m falhou na segunda tentativa:", retryError);
                throw new Error("Execu√ß√£o do contrato falhou - execution reverted. A transfer√™ncia de tokens n√£o foi completada mesmo ap√≥s nova tentativa.");
              }
            }
            
            // Verificar logs para confirmar que o evento TokensDistributed foi emitido
            let eventEmitted = false;
            if (receipt.logs && receipt.logs.length > 0) {
              for (const log of receipt.logs) {
                if (log.address.toLowerCase() === this.distributorAddress?.toLowerCase()) {
                  eventEmitted = true;
                  console.log("‚úÖ Evento emitido pelo contrato distribuidor detectado");
                  break;
                }
              }
            }
            
            if (!eventEmitted) {
              console.warn("‚ö†Ô∏è Transa√ß√£o confirmada, mas nenhum evento do contrato distribuidor foi detectado");
              console.log("A transa√ß√£o pode ter falhado silenciosamente. Verifique em: https://polygonscan.com/tx/" + tx.hash);
            }
          } else {
            console.warn("Tempo limite excedido esperando confirma√ß√£o. A transa√ß√£o ainda pode ser confirmada posteriormente.");
            console.log("Voc√™ pode verificar o status da transa√ß√£o em https://polygonscan.com/tx/" + tx.hash);
          }
        }
        
        return tx.hash;
      } catch (contractError: any) {
        console.error("‚ùå Erro ao chamar contrato.distributeTokens:", contractError);
        
        // Tentar extrair informa√ß√µes mais √∫teis do erro
        let errorMessage = "Erro ao chamar contrato";
        
        if (contractError.error?.message) {
          errorMessage = contractError.error.message;
        } else if (contractError.message) {
          errorMessage = contractError.message;
        }
        
        if (errorMessage.includes("gas required exceeds")) {
          throw new Error(`Erro no gas: ${errorMessage}. Aumente o gas limit para esta transa√ß√£o.`);
        } else if (errorMessage.includes("nonce")) { 
          throw new Error(`Erro no nonce: ${errorMessage}. Pode haver uma transa√ß√£o pendente.`);
        } else {
          throw new Error(`Erro ao distribuir tokens: ${errorMessage}`);
        }
      }
      
      // O c√≥digo abaixo s√≥ √© executado se a tentativa de usar o contrato diretamente falhar
      // -----------------------------------------------------------------------------
      
      // Preparar dados para a transa√ß√£o como fallback
      const ABI = ["function distributeTokens(address donor, uint256 donationAmountUsd)"];
      const iface = new ethers.utils.Interface(ABI);
      const calldata = iface.encodeFunctionData("distributeTokens", [donorAddress, usdValueScaled]);
      
      // Construir transa√ß√£o com par√¢metros EIP-1559 adequados para Polygon
      const tx = {
        to: this.distributorAddress || undefined, // Convertendo null para undefined para satisfazer TransactionRequest
        maxFeePerGas: maxFeePerGas,
        maxPriorityFeePerGas: maxPriorityFeePerGas,
        gasLimit: ethers.utils.hexlify(gasLimit),
        data: calldata,
        nonce: nonce,
        chainId: 137, // Polygon mainnet
        type: 2 // Tipo EIP-1559
      };
      
      console.log("Enviando transa√ß√£o com configura√ß√µes:", {
        maxFeePerGas: ethers.utils.formatUnits(maxFeePerGas, "gwei") + " gwei",
        maxPriorityFeePerGas: ethers.utils.formatUnits(maxPriorityFeePerGas, "gwei") + " gwei",
        gasLimit: gasLimit.toString(),
        nonce: nonce,
        tipo: "EIP-1559 (tipo 2)"
      });
      
      // Assinar e enviar
      console.log("Enviando transa√ß√£o manual (fallback method)...");
      const signedTx = await this.wallet!.signTransaction(tx);
      const submittedTx = await this.provider!.sendTransaction(signedTx);
      
      console.log(`Transa√ß√£o enviada: ${submittedTx.hash}`);
      
      // Aguardar confirma√ß√£o se necess√°rio
      if (waitForConfirmation) {
        console.log(`Aguardando confirma√ß√£o da transa√ß√£o ${submittedTx.hash}...`);
        
        // C√≥digo de espera por confirma√ß√£o...
        // ...existing code...
      }
      
      return submittedTx.hash;
    } catch (error: any) {
      console.error("‚ùå Erro ao distribuir tokens G33:", error);
      
      // Extrair detalhes do erro
      if (error.error?.body) {
        try {
          const errorBody = JSON.parse(error.error.body);
          console.error("Detalhes do erro blockchain:", {
            code: errorBody.error?.code,
            message: errorBody.error?.message,
            data: errorBody.error?.data
          });
          
          // Verificar se o erro √© relacionado a gas price baixo
          if (errorBody.error?.message && errorBody.error.message.includes("gas tip cap")) {
            const errorMsg = errorBody.error.message;
            // Extrair o valor m√≠nimo requerido
            const minGasMatch = errorMsg.match(/minimum needed (\d+)/);
            if (minGasMatch && minGasMatch[1]) {
              const minGasNeeded = parseInt(minGasMatch[1], 10);
              console.log(`‚ö†Ô∏è Gas tip cap muito baixo. M√≠nimo necess√°rio: ${minGasNeeded / 1_000_000_000} gwei`);
              
              // Aqui voc√™ poderia implementar um retry autom√°tico com valor maior
              throw new Error(`Gas tip cap insuficiente. O m√≠nimo necess√°rio √© ${minGasNeeded / 1_000_000_000} gwei. Tente novamente com um valor maior.`);
            }
          }
        } catch (parseError) {
          console.error("Erro ao processar detalhes do erro:", parseError);
        }
      }
      
      // An√°lise do erro mais precisa para gas price
      if (error.message) {
        if (error.message.includes("gas tip cap") || error.message.includes("underpriced")) {
          // Verificar se a mensagem inclui o valor m√≠nimo necess√°rio
          const minGasMatch = error.message.match(/minimum needed (\d+)/);
          if (minGasMatch && minGasMatch[1]) {
            const minGasNeeded = parseInt(minGasMatch[1], 10);
            const minGasInGwei = minGasNeeded / 1_000_000_000;
            console.log(`‚ö†Ô∏è Gas price muito baixo. M√≠nimo necess√°rio: ${minGasInGwei} gwei`);
            throw new Error(`Transa√ß√£o com gas price muito baixo. A rede Polygon exige no m√≠nimo ${minGasInGwei} gwei. Consulte https://polygonscan.com/gastracker para valores atuais.`);
          } else {
            throw new Error(`Transa√ß√£o com gas price muito baixo para a rede Polygon. Consulte https://polygonscan.com/gastracker para valores atuais.`);
          }
        } else if (error.code === "INSUFFICIENT_FUNDS") {
          throw new Error("Fundos insuficientes para enviar a transa√ß√£o. Por favor, adicione MATIC √† carteira distribuidora.");
        } else if (error.code === "NONCE_EXPIRED") {
          throw new Error(`Erro de nonce: ${error.message}. Tente novamente.`);
        } else if (error.code === "REPLACEMENT_UNDERPRICED") {
          throw new Error(`Transa√ß√£o com gas price muito baixo. Aumente o gas price e tente novamente.`);
        }
      }
      
      // Erro gen√©rico
      throw new Error(`Falha ao distribuir tokens G33: ${error.message || JSON.stringify(error)}`);
    }
  }

  /**
   * Registra uma doa√ß√£o e distribui tokens G33 automaticamente
   * @param donorAddress Endere√ßo do doador
   * @param donationAmount Valor doado em criptomoeda
   * @param usdValue Valor equivalente em USD
   * @param tokenAmount Quantidade de tokens a distribuir
   * @param transactionHash Hash da transa√ß√£o de doa√ß√£o
   * @param network Rede da doa√ß√£o
   * @param cryptoSymbol S√≠mbolo da criptomoeda usada
   * @returns Um objeto contendo o ID do documento no Firebase e o status da distribui√ß√£o
   * @throws Error se a distribui√ß√£o de tokens falhar
   */
  async processDonation(
    donorAddress: string,
    donationAmount: number,
    usdValue: number,
    tokenAmount: number,
    transactionHash: string,
    network: string,
    cryptoSymbol: string
  ): Promise<{id: string, success: boolean, distributionTxHash?: string, error?: string}> {
    // Criar objeto para registrar a doa√ß√£o
    const tokenDonation: TokenDonation = {
      donorAddress,
      donationAmount,
      usdValue,
      tokenAmount,
      transactionHash,
      network,
      cryptoSymbol,
      createdAt: new Date(),
      status: 'pending'
    };
    
    // Adicionar ao Firebase com status inicial 'pending'
    const docRef = await addDoc(collection(db, 'tokenDonations'), tokenDonation);
    const donationId = docRef.id;
    
    try {
      console.log(`Processando doa√ß√£o para distribui√ß√£o de tokens: ${tokenAmount} G33 para ${donorAddress}`);
      
      // MUITO IMPORTANTE: Verificar inicializa√ß√£o antes de tentar distribuir
      if (!(await this.ensureInitialized())) {
        const errorMsg = `Servi√ßo distribuidor n√£o inicializado. Erro: ${this.initializationError || "Desconhecido"}`;
        console.error(errorMsg);
        
        // Atualizar o status da doa√ß√£o para 'failed'
        await updateDoc(docRef, {
          status: 'failed',
          error: errorMsg
        });
        
        // Lan√ßar erro para interromper o processamento da doa√ß√£o
        throw new Error(errorMsg);
      }
      
      // Tentar distribuir os tokens
      const distributionTxHash = await this.distributeTokens(donorAddress, usdValue);
      
      if (!distributionTxHash) {
        const errorMsg = 'Falha na distribui√ß√£o de tokens - transa√ß√£o blockchain n√£o completada';
        console.error(errorMsg);
        
        // Atualizar o status da doa√ß√£o para 'failed'
        await updateDoc(docRef, {
          status: 'failed',
          error: errorMsg
        });
        
        // Lan√ßar erro para interromper o processamento da doa√ß√£o
        throw new Error(errorMsg);
      }
      
      // Distribui√ß√£o bem-sucedida - atualizar o registro
      await updateDoc(docRef, {
        status: 'distributed',
        distributionTxHash
      });
      
      console.log(`Doa√ß√£o processada e tokens distribu√≠dos com sucesso: ${tokenAmount} G33 para ${donorAddress}`);
      
      // Retornar sucesso com o hash da transa√ß√£o de distribui√ß√£o
      return {
        id: donationId,
        success: true,
        distributionTxHash
      };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : "Erro desconhecido";
      console.error("Erro cr√≠tico ao processar distribui√ß√£o de tokens:", errorMessage);
      
      // Atualizar status para falha
      await updateDoc(docRef, {
        status: 'failed',
        error: errorMessage
      });
      
      // Retornar falha e propagar o erro
      return {
        id: donationId,
        success: false,
        error: errorMessage
      };
    }
  }

  /**
   * Obt√©m o total de tokens dispon√≠veis para distribui√ß√£o
   * @returns Quantidade de tokens dispon√≠veis ou 0 se n√£o for poss√≠vel obter
   */
  async getAvailableTokens(): Promise<string> {
    try {
      if (!(await this.ensureInitialized())) {
        return "0";
      }
      
      const availableTokens = await this.contract!.getAvailableTokens();
      return ethers.utils.formatEther(availableTokens);
    } catch (error) {
      console.error("Erro ao obter tokens dispon√≠veis:", error);
      return "0";
    }
  }

  /**
   * Obt√©m estat√≠sticas de distribui√ß√£o
   */
  async getDistributionStats() {
    try {
      if (!(await this.ensureInitialized())) {
        return {
          totalDistributed: "0",
          totalDonationsUsd: "0",
          availableTokens: "0"
        };
      }
      
      const [totalDistributed, totalDonationsUsd, availableTokens] = await Promise.all([
        this.contract!.totalDistributedTokens(),
        this.contract!.totalDonationsUsd(),
        this.contract!.getAvailableTokens()
      ]);
      
      return {
        totalDistributed: ethers.utils.formatEther(totalDistributed),
        // totalDonationsUsd √© armazenado com 2 casas decimais extras (x100)
        totalDonationsUsd: (Number(totalDonationsUsd) / 100).toString(),
        availableTokens: ethers.utils.formatEther(availableTokens)
      };
    } catch (error) {
      console.error("Erro ao obter estat√≠sticas de distribui√ß√£o:", error);
      return {
        totalDistributed: "0",
        totalDonationsUsd: "0",
        availableTokens: "0"
      };
    }
  }

  /**
   * Obt√©m o total de tokens j√° distribu√≠dos para um doador espec√≠fico
   * @param donorAddress Endere√ßo do doador
   */
  async getTokensDistributedToDonor(donorAddress: string): Promise<string> {
    try {
      if (!(await this.ensureInitialized())) {
        return "0";
      }
      
      const tokenAmount = await this.contract!.tokensDistributed(donorAddress);
      return ethers.utils.formatEther(tokenAmount);
    } catch (error) {
      console.error(`Erro ao obter tokens distribu√≠dos para ${donorAddress}:`, error);
      return "0";
    }
  }

  /**
   * Obt√©m o recibo de uma transa√ß√£o pelo seu hash
   * @param txHash Hash da transa√ß√£o
   * @returns Recibo da transa√ß√£o ou null se n√£o encontrado
   */
  async getTransactionReceipt(txHash: string): Promise<ethers.providers.TransactionReceipt | null> {
    try {
      if (!(await this.ensureInitialized())) {
        return null;
      }
      
      if (!this.provider) {
        console.error("Provider n√£o dispon√≠vel para verificar recibo da transa√ß√£o");
        return null;
      }
      
      return await this.provider.getTransactionReceipt(txHash);
    } catch (error) {
      console.error(`Erro ao obter recibo da transa√ß√£o ${txHash}:`, error);
      return null;
    }
  }
}

// Ensure the service is initialized only on the server side
if (typeof window !== "undefined") {
  console.error("G33TokenDistributorService n√£o pode ser inicializado no cliente. Ignorando inicializa√ß√£o.");
  throw new Error("Execu√ß√£o no cliente detectada. Servi√ßo n√£o ser√° inicializado.");
}

// Exportar a inst√¢ncia do servi√ßo
export const g33TokenDistributorService = new G33TokenDistributorService();

// Atualizar o endere√ßo do contrato distribuidor no Firebase
(async () => {
  try {
    const distributorAddress = "0x137c762cb3eea5c8e5a6ed2fdf41dd47b5e13455"; // Endere√ßo do novo contrato G33TokenDistributorV2
    await updateDoc(doc(db, "settings", "contractConfig"), {
      tokenDistributorAddress: distributorAddress
    });
    console.log("Endere√ßo do contrato distribuidor atualizado no Firebase");
  } catch (err) {
    console.error("Erro ao atualizar endere√ßo do contrato no Firebase:", err);
  }
})();

console.log("--- Verificando contexto de execu√ß√£o ---");
console.log("process.env.NODE_ENV:", process.env.NODE_ENV);
console.log("process.env.DISTRIBUTOR_PRIVATE_KEY:", process.env.DISTRIBUTOR_PRIVATE_KEY ? "[REDACTED]" : "N√£o encontrada");

// Ensure DISTRIBUTOR_PRIVATE_KEY-dependent logic is skipped on the client side
if (typeof window !== "undefined") {
  console.error("Este c√≥digo est√° sendo executado no lado do cliente. Vari√°veis de ambiente privadas n√£o est√£o dispon√≠veis no cliente.");
  throw new Error("Execu√ß√£o no cliente detectada. L√≥gica dependente de DISTRIBUTOR_PRIVATE_KEY ser√° ignorada.");
}

if (typeof window !== "undefined") {
  console.error("Este c√≥digo est√° sendo executado no lado do cliente. Vari√°veis de ambiente privadas n√£o est√£o dispon√≠veis no cliente.");
} else {
  console.log("Este c√≥digo est√° sendo executado no lado do servidor.");
}

export default g33TokenDistributorService;